<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>SABDA — Room Simulator v3</title>
<style>
*{margin:0;padding:0}
html,body{width:100%;height:100%;overflow:hidden;background:#000}
#mount canvas{position:absolute;top:0;left:0}
#loading{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;
  align-items:center;justify-content:center;background:#0e0a0d;z-index:100;
  font-family:'Georgia',serif;color:#c4a882;font-size:1.2rem;letter-spacing:0.2em;
  transition:opacity 2s ease-out}
#loading.done{opacity:0;pointer-events:none}
#info{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);z-index:50;
  font-family:system-ui;color:rgba(255,255,255,0.45);font-size:11px;
  background:rgba(0,0,0,0.3);padding:6px 14px;border-radius:20px;
  pointer-events:none;text-align:center;backdrop-filter:blur(6px);
  transition:opacity 4s;letter-spacing:0.05em}
#info.hide{opacity:0}
</style>
</head>
<body>
<div id="loading">S A B D A</div>
<div id="info">drag to look around · scroll to zoom</div>
<div id="mount"></div>

<!-- ═══ EMBEDDED ASSETS ═══ -->
<script id="skydata" type="text/plain">ASSET_PLACEHOLDER</script>
<script id="birdsdata" type="text/plain">ASSET_PLACEHOLDER</script>
<script id="planetdata" type="text/plain">ASSET_PLACEHOLDER</script>
<script id="saturndata" type="text/plain">ASSET_PLACEHOLDER</script>

<script type="importmap">{"imports":{
  "three":"https://unpkg.com/three@0.162.0/build/three.module.js",
  "three/addons/":"https://unpkg.com/three@0.162.0/examples/jsm/"
}}</script>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

/* ═══════════════════════════════════════════════════════
   SABDA Room Simulator v3 — Performance Optimized (v10)
   
   Changes from v8:
   - Butterflies + trail shimmer REMOVED (placeholder for bird models)
   - pixelRatio capped at 2 (was 3) — reduces GPU fill cost
   - 3 glow lights per long wall (was 2), better coverage
   - Room fog for atmospheric depth  
   - Glow lights breathe with content cycle
   - Bird banking smoothed, reduced intensity
   - Subtle floor texture via noise canvas
   - CubeRT mipmaps enabled for smoother sampling
   - Auto-hide info text after 6 seconds
   - Cleaner loading screen
   ═══════════════════════════════════════════════════════ */

// ── SABDA ROOM DIMENSIONS (confirmed) ──
const ROOM_L = 15.00;   // length (Z axis)
const ROOM_W = 5.63;    // width (X axis)
const ROOM_H = 3.23;    // height (Y axis)
const EYE_H = 1.6;
const PERIM = 2 * ROOM_L + 2 * ROOM_W;  // 41.26m
const BREATH = 14, CCYCLE = 90;

// ═══════════════════════════════════════════════════════
// SCENE A: CONTENT SCENE
// ═══════════════════════════════════════════════════════
const contentScene = new THREE.Scene();

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.getElementById('mount').appendChild(renderer.domElement);

// CubeCamera — 2560 per face, maximum source resolution
// v5: Adaptive quality — 4K cube for RTX 4080, 2560 for laptops
const gl = renderer.getContext();
const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
const gpuName = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';
const isMobile = /iPhone|iPad|Android|Mobile/i.test(navigator.userAgent);
const CUBE_SIZE = isMobile ? 1024 : 4096;
const STRIP_W_VAL = isMobile ? 4096 : 12288;
const MSAA_SAMPLES = isMobile ? 4 : 8;
console.log(`GPU: ${gpuName} | Mobile: ${isMobile} → Cube ${CUBE_SIZE}, Strip ${STRIP_W_VAL}, MSAA ${MSAA_SAMPLES}×`);
const cubeRT = new THREE.WebGLCubeRenderTarget(CUBE_SIZE, {
  generateMipmaps: true,
  minFilter: THREE.LinearMipmapLinearFilter,
  type: THREE.HalfFloatType,  // 16-bit precision — eliminates banding in dark gradients
});
const cubeCamera = new THREE.CubeCamera(0.05, 500, cubeRT);
cubeCamera.position.set(0, EYE_H, 0);
contentScene.add(cubeCamera);

// Equirect strip — 8K oversampled for maximum sharpness
const STRIP_W = STRIP_W_VAL;
const STRIP_H = Math.round(STRIP_W / 5.76);
const stripRT = new THREE.WebGLRenderTarget(STRIP_W, STRIP_H, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.LinearFilter,
  colorSpace: THREE.SRGBColorSpace,
  samples: MSAA_SAMPLES,
});

const VFOV_RAD = 62.5 * Math.PI / 180.0;
const ELEV_OFFSET = 3.0 * Math.PI / 180.0;

const equirectMat = new THREE.ShaderMaterial({
  uniforms: {
    tCube: { value: null },
    vFovRad: { value: VFOV_RAD },
    elevOffset: { value: ELEV_OFFSET },
  },
  vertexShader: `
    varying vec2 vUv;
    void main() { vUv = uv; gl_Position = vec4(position.xy, 0.0, 1.0); }
  `,
  fragmentShader: `
    precision highp float;
    uniform samplerCube tCube;
    uniform float vFovRad;
    uniform float elevOffset;
    varying vec2 vUv;
    // Dithering: breaks up 8-bit color banding in dark gradients
    // Standard technique from film/TV color grading
    float dither(vec2 co) {
      return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453) - 0.5;
    }
    void main() {
      float azimuth = vUv.x * 6.283185307;
      float elevation = (vUv.y - 0.5) * vFovRad + elevOffset;
      float ce = cos(elevation);
      vec3 dir = vec3(sin(azimuth) * ce, sin(elevation), -cos(azimuth) * ce);
      vec4 col = textureCube(tCube, dir);
      // Add ±0.5 LSB dithering noise — invisible but eliminates banding
      col.rgb += dither(gl_FragCoord.xy) / 255.0;
      gl_FragColor = col;
    }
  `,
  depthWrite: false,
  depthTest: false,
});

const equirectScene = new THREE.Scene();
const equirectCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
equirectScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), equirectMat));

// ── CONTENT SCENE SETUP ──
const tl = new THREE.TextureLoader();
function b64T(id, m) {
  const t = tl.load('data:' + m + ';base64,' + document.getElementById(id).textContent.trim());
  t.colorSpace = THREE.SRGBColorSpace; return t;
}
const skyTex = b64T('skydata', 'image/png');
skyTex.mapping = THREE.EquirectangularReflectionMapping;
skyTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
skyTex.minFilter = THREE.LinearMipmapLinearFilter;
skyTex.magFilter = THREE.LinearFilter;
skyTex.generateMipmaps = true;

// Sky sphere — rotatable for slow cloud drift, keeps full texture sharpness
const skySphereGeo = new THREE.SphereGeometry(400, 64, 32);
const skySphereMat = new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide, fog: false });
const skySphere = new THREE.Mesh(skySphereGeo, skySphereMat);
contentScene.add(skySphere);
contentScene.background = null;  // Use sphere instead of flat background
contentScene.environment = skyTex;  // Environment lighting stays static (fine)


// Lighting — warm multi-source
const ambient = new THREE.AmbientLight(0x6a5540, 0.4); contentScene.add(ambient);
const hemi = new THREE.HemisphereLight(0xc48040, 0x1a2520, 0.4); contentScene.add(hemi);
const sun = new THREE.DirectionalLight(0xff9050, 0.8); sun.position.set(10, 15, -8); contentScene.add(sun);
const rim = new THREE.DirectionalLight(0x405080, 0.3); rim.position.set(-10, 8, 8); contentScene.add(rim);
const fill = new THREE.DirectionalLight(0xcc6030, 0.2); fill.position.set(0, 5, 15); contentScene.add(fill);

// ── ATMOSPHERIC DEPTH FOG ──
contentScene.fog = new THREE.FogExp2(0x9a7a90, 0.003);

// ── STAR FIELD — upper hemisphere, fades with sky warmth ──
const STAR_COUNT = 200;
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(STAR_COUNT * 3);
const starSizes = new Float32Array(STAR_COUNT);
const starTwinkle = new Float32Array(STAR_COUNT);  // phase offset for twinkle
for (let i = 0; i < STAR_COUNT; i++) {
  // Upper hemisphere only — elevation 15° to 85° above horizon
  const theta = Math.random() * Math.PI * 2;
  const elev = (15 + Math.random() * 70) * Math.PI / 180;
  const r = 350 + Math.random() * 40;  // Just inside sky sphere
  starPos[i * 3]     = Math.cos(elev) * Math.cos(theta) * r;
  starPos[i * 3 + 1] = Math.sin(elev) * r;
  starPos[i * 3 + 2] = Math.cos(elev) * Math.sin(theta) * r;
  starSizes[i] = 1.0 + Math.random() * 2.5;
  starTwinkle[i] = Math.random() * Math.PI * 2;
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
const starMat = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 },
    uOpacity: { value: 0 },  // Controlled by sky warmth cycle
  },
  vertexShader: `
    attribute float size;
    varying float vTwinkle;
    uniform float uTime;
    void main() {
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      // Twinkle — each star has its own rhythm
      vTwinkle = 0.5 + 0.5 * sin(uTime * (1.5 + position.x * 0.01) + position.y * 0.02);
      gl_PointSize = size * (6.0 / -mvPos.z);
      gl_Position = projectionMatrix * mvPos;
    }
  `,
  fragmentShader: `
    uniform float uOpacity;
    varying float vTwinkle;
    void main() {
      float d = length(gl_PointCoord - vec2(0.5));
      if (d > 0.5) discard;
      float core = smoothstep(0.5, 0.0, d);
      float alpha = core * vTwinkle * uOpacity;
      gl_FragColor = vec4(0.95, 0.92, 1.0, alpha);
    }
  `,
  transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, fog: false,
});
const starField = new THREE.Points(starGeo, starMat);
starField.frustumCulled = false;
contentScene.add(starField);

// ── GOD RAYS — faked volumetric light shafts from horizon ──
const rayGroup = new THREE.Group();
const RAY_COUNT = 3;
const rayMeshes = [];
for (let i = 0; i < RAY_COUNT; i++) {
  const angle = -0.3 + (i / (RAY_COUNT - 1)) * 0.6;  // Narrower arc
  const width = 40 + Math.random() * 30;   // Much wider — soft beams not pillars
  const height = 80 + Math.random() * 60;
  const geo = new THREE.PlaneGeometry(width, height);
  const cvs = document.createElement('canvas');
  cvs.width = 4; cvs.height = 128;
  const ctx = cvs.getContext('2d');
  const grd = ctx.createLinearGradient(0, 128, 0, 0);
  grd.addColorStop(0, 'rgba(255,200,120,0.04)');
  grd.addColorStop(0.2, 'rgba(255,180,100,0.025)');
  grd.addColorStop(0.5, 'rgba(255,160,80,0.008)');
  grd.addColorStop(1.0, 'rgba(255,140,60,0.0)');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, 4, 128);
  const rayTex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.MeshBasicMaterial({
    map: rayTex, transparent: true, depthWrite: false,
    blending: THREE.AdditiveBlending, side: THREE.DoubleSide, fog: false,
  });
  const mesh = new THREE.Mesh(geo, mat);
  // Position at horizon, angled upward
  const dist = 200;
  mesh.position.set(Math.sin(angle) * dist, height * 0.3, -Math.cos(angle) * dist);
  mesh.rotation.x = -0.15 + Math.random() * 0.1;  // Slight tilt variation
  mesh.rotation.y = angle;
  mesh.rotation.z = (Math.random() - 0.5) * 0.08;
  rayMeshes.push(mesh);
  rayGroup.add(mesh);
}
contentScene.add(rayGroup);

// ── SHOOTING STAR SYSTEM ──
const shootingStarState = {
  active: false,
  timer: 8,
  pos: new THREE.Vector3(),
  vel: new THREE.Vector3(),
  life: 0, maxLife: 0,
};

// Head: bright glowing sphere
const ssHeadGeo = new THREE.SphereGeometry(1.5, 8, 8);
const ssHeadMat = new THREE.MeshBasicMaterial({ 
  color: 0xfff8e0, fog: false, toneMapped: false 
});
const ssHead = new THREE.Mesh(ssHeadGeo, ssHeadMat);
ssHead.visible = false;
contentScene.add(ssHead);

// Tail: tapered cone
const ssTailGeo = new THREE.CylinderGeometry(0.0, 1.2, 1.0, 8, 1);
const ssTailMat = new THREE.MeshBasicMaterial({ 
  color: 0xffe0a0, fog: false, transparent: true, opacity: 0.7, toneMapped: false
});
const ssTail = new THREE.Mesh(ssTailGeo, ssTailMat);
ssTail.visible = false;
contentScene.add(ssTail);

// ── FLOATING DUST / POLLEN PARTICLES ──
const DUST_COUNT = 250;
const dustGeo = new THREE.BufferGeometry();
const dustPositions = new Float32Array(DUST_COUNT * 3);
const dustSizes = new Float32Array(DUST_COUNT);
const dustSpeeds = new Float32Array(DUST_COUNT * 3);  // per-particle drift velocity
const dustPhases = new Float32Array(DUST_COUNT);       // per-particle phase for shimmer

for (let i = 0; i < DUST_COUNT; i++) {
  // Distribute in a sphere around camera, 3m to 30m range
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  const r = 3 + Math.random() * 27;
  dustPositions[i * 3]     = Math.sin(phi) * Math.cos(theta) * r;
  dustPositions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * r;
  dustPositions[i * 3 + 2] = Math.cos(phi) * r;
  // Closer particles are slightly larger (0.8-2.5px)
  dustSizes[i] = (1.0 - (r - 3) / 27) * 1.7 + 0.8;
  // Gentle drift — mostly upward, slight horizontal wander
  dustSpeeds[i * 3]     = (Math.random() - 0.5) * 0.003;
  dustSpeeds[i * 3 + 1] = 0.001 + Math.random() * 0.003;  // Upward drift
  dustSpeeds[i * 3 + 2] = (Math.random() - 0.5) * 0.003;
  dustPhases[i] = Math.random() * Math.PI * 2;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
dustGeo.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));

const dustMat = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 },
    uColor: { value: new THREE.Color(0xffe0a0) },  // Warm golden pollen
    uOpacity: { value: 0.35 },
  },
  vertexShader: `
    attribute float size;
    uniform float uTime;
    varying float vAlpha;
    void main() {
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      float dist = length(mvPos.xyz);
      // Fade out at extremes — invisible up close, dim far away
      float distFade = smoothstep(2.0, 5.0, dist) * (1.0 - smoothstep(25.0, 35.0, dist));
      // Shimmer — subtle brightness variation
      float shimmer = 0.7 + 0.3 * sin(uTime * 1.5 + position.x * 3.0 + position.y * 2.0);
      vAlpha = distFade * shimmer;
      gl_PointSize = size * (8.0 / -mvPos.z);
      gl_Position = projectionMatrix * mvPos;
    }
  `,
  fragmentShader: `
    uniform vec3 uColor;
    uniform float uOpacity;
    varying float vAlpha;
    void main() {
      // Soft circular particle
      float d = length(gl_PointCoord - vec2(0.5));
      if (d > 0.5) discard;
      float alpha = (1.0 - d * 2.0) * vAlpha * uOpacity;
      gl_FragColor = vec4(uColor, alpha);
    }
  `,
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
});

const dustSystem = new THREE.Points(dustGeo, dustMat);
dustSystem.frustumCulled = false;
contentScene.add(dustSystem);

// ── PLANET ──
let planetMixer = null, glowMat = null;
const planetGroup = new THREE.Group();
const plDist = 85, plAngle = Math.PI + 0.85, plElev = 15 * Math.PI / 180;
planetGroup.position.set(
  Math.cos(plAngle) * Math.cos(plElev) * plDist,
  Math.sin(plElev) * plDist,
  Math.sin(plAngle) * Math.cos(plElev) * plDist
);
planetGroup.scale.setScalar(13.5);
planetGroup.rotation.z = 0.12;
planetGroup.rotation.x = -0.08;

// Glow halo
const glowCanvas = document.createElement('canvas');
glowCanvas.width = 512; glowCanvas.height = 512;
const gCtx = glowCanvas.getContext('2d');
const g1 = gCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
g1.addColorStop(0, 'rgba(200,160,240,0.3)');
g1.addColorStop(0.05, 'rgba(190,150,230,0.2)');
g1.addColorStop(0.15, 'rgba(170,130,210,0.08)');
g1.addColorStop(0.3, 'rgba(150,110,190,0.02)');
g1.addColorStop(0.5, 'rgba(130,90,170,0.0)');
g1.addColorStop(1.0, 'rgba(100,60,140,0.0)');
gCtx.fillStyle = g1; gCtx.fillRect(0, 0, 512, 512);
const glowTx = new THREE.CanvasTexture(glowCanvas);
glowMat = new THREE.SpriteMaterial({ map: glowTx, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, fog: false });
const glowSprite = new THREE.Sprite(glowMat);
glowSprite.scale.setScalar(6.0);
planetGroup.add(glowSprite);
contentScene.add(planetGroup);

// ── SATURN STAR ── (Distant star-like, top centre of Wall D)
const saturnGroup = new THREE.Group();
const satAngle = 0, satDist = 85, satElev = 18 * Math.PI / 180;  // Top centre Wall D
saturnGroup.position.set(
  Math.cos(satAngle) * Math.cos(satElev) * satDist,
  Math.sin(satElev) * satDist,
  Math.sin(satAngle) * Math.cos(satElev) * satDist
);
saturnGroup.scale.setScalar(10);  // Was working — distant star appearance
saturnGroup.rotation.x = -0.25;
saturnGroup.rotation.z = 0.15;

// Warm golden glow
const satGlowCvs = document.createElement('canvas');
satGlowCvs.width = 512; satGlowCvs.height = 512;
const sgCtx = satGlowCvs.getContext('2d');
const sg1 = sgCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
sg1.addColorStop(0, 'rgba(240,200,140,0.25)');
sg1.addColorStop(0.05, 'rgba(230,190,130,0.15)');
sg1.addColorStop(0.15, 'rgba(210,170,110,0.06)');
sg1.addColorStop(0.3, 'rgba(190,150,100,0.015)');
sg1.addColorStop(0.5, 'rgba(170,130,80,0.0)');
sg1.addColorStop(1.0, 'rgba(140,100,60,0.0)');
sgCtx.fillStyle = sg1; sgCtx.fillRect(0, 0, 512, 512);
const satGlowTx = new THREE.CanvasTexture(satGlowCvs);
const satGlowMat = new THREE.SpriteMaterial({ map: satGlowTx, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, fog: false });
const satGlowSprite = new THREE.Sprite(satGlowMat);
satGlowSprite.scale.setScalar(5.5);
saturnGroup.add(satGlowSprite);
contentScene.add(saturnGroup);

// ── SATURN MAIN ── (Full-size, Wall D diagonal opposite of fantasy planet)
const saturnMainGroup = new THREE.Group();
const satMainAngle = 0.85, satMainDist = 85, satMainElev = 15 * Math.PI / 180;  // Wall D toward A, diagonal opposite of fantasy planet
saturnMainGroup.position.set(
  Math.cos(satMainAngle) * Math.cos(satMainElev) * satMainDist,
  Math.sin(satMainElev) * satMainDist,
  Math.sin(satMainAngle) * Math.cos(satMainElev) * satMainDist
);
saturnMainGroup.scale.setScalar(0.023);  // Model ~1200 units after root; 0.023 → body ~28 units (matches fantasy planet)
saturnMainGroup.rotation.x = -0.3;     // Tilt rings toward viewer
saturnMainGroup.rotation.z = 0.12;

// Saturn main glow — warm golden, same size as fantasy planet glow
const satMGlowCvs = document.createElement('canvas');
satMGlowCvs.width = 512; satMGlowCvs.height = 512;
const smgCtx = satMGlowCvs.getContext('2d');
const smg1 = smgCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
smg1.addColorStop(0, 'rgba(240,200,140,0.3)');
smg1.addColorStop(0.05, 'rgba(230,190,130,0.2)');
smg1.addColorStop(0.15, 'rgba(210,170,110,0.08)');
smg1.addColorStop(0.3, 'rgba(190,150,100,0.02)');
smg1.addColorStop(0.5, 'rgba(170,130,80,0.0)');
smg1.addColorStop(1.0, 'rgba(140,100,60,0.0)');
smgCtx.fillStyle = smg1; smgCtx.fillRect(0, 0, 512, 512);
const satMGlowTx = new THREE.CanvasTexture(satMGlowCvs);
const satMGlowMat = new THREE.SpriteMaterial({ map: satMGlowTx, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, fog: false });
const satMGlowSprite = new THREE.Sprite(satMGlowMat);
satMGlowSprite.scale.setScalar(260);  // 260 * 0.023 ≈ 6 world units
saturnMainGroup.add(satMGlowSprite);
contentScene.add(saturnMainGroup);

// ── GLB LOADER ──
function b64ToUrl(id, mime) {
  const b = document.getElementById(id).textContent.trim();
  const d = atob(b); const u = new Uint8Array(d.length);
  for (let i = 0; i < d.length; i++) u[i] = d.charCodeAt(i);
  return URL.createObjectURL(new Blob([u], { type: mime }));
}

const loader = new GLTFLoader();
const birdFlocks = [];
let readyCount = 0;
function checkReady() {
  readyCount++;
  if (readyCount >= 4) {  // birds + planet + saturn star + saturn main
    document.getElementById('loading').classList.add('done');
    // Auto-hide info text after 6s
    setTimeout(() => document.getElementById('info').classList.add('hide'), 6000);
  }
}





// ── BIRDS ──
const birdsUrl = b64ToUrl('birdsdata', 'model/gltf-binary');
loader.load(birdsUrl, gltf => {
  URL.revokeObjectURL(birdsUrl);
  const clip = gltf.animations[0];
  const configs = [
    { angle: 0.0, dist: 18, y: 3.5, scale: 2.5 },
    { angle: 1.05, dist: 24, y: 4.8, scale: 2.0 },
    { angle: 2.1, dist: 30, y: 3.8, scale: 1.6 },
    { angle: 3.15, dist: 20, y: 5.5, scale: 1.8 },
    { angle: 4.2, dist: 26, y: 4.2, scale: 2.2 },
    { angle: 5.25, dist: 22, y: 3.2, scale: 1.7 },
  ];
  for (let fi = 0; fi < configs.length; fi++) {
    const fc = configs[fi];
    const ctr = new THREE.Group();
    ctr.position.set(Math.cos(fc.angle) * fc.dist, fc.y, Math.sin(fc.angle) * fc.dist);
    const clone = SkeletonUtils.clone(gltf.scene);
    clone.scale.setScalar(fc.scale);
    clone.traverse(c => {
      if (c.isMesh) {
        c.frustumCulled = false;
        const isY = c.material ? c.material.name === 'Yellow' : false;
        c.material = new THREE.MeshStandardMaterial({
          color: isY ? 0xa08030 : 0x352010,
          roughness: 0.5, metalness: 0, side: THREE.DoubleSide,
          emissive: isY ? new THREE.Color(0x605020) : new THREE.Color(0x201008),
          emissiveIntensity: 0.15,
        });
      }
    });
    ctr.add(clone);
    contentScene.add(ctr);
    const mixer = new THREE.AnimationMixer(clone);
    const action = mixer.clipAction(clip);
    const bts = 0.4 + fi * 0.06;
    action.timeScale = bts;
    action.play();
    const heading = fc.angle + Math.PI / 2 + (Math.random() - 0.5) * 0.3;
    birdFlocks.push({
      ctr, mixer, action, heading,
      cruiseSpeed: 0.015 + Math.random() * 0.008,
      vy: 0, homeY: fc.y, homeDist: fc.dist,
      turnRate: 0,
      desiredTurnRate: (Math.random() - 0.5) * 0.015,
      turnChangeTimer: 10 + Math.random() * 15,
      isGliding: false, glideTimer: 3 + Math.random() * 4,
      glideDuration: 1.5 + Math.random() * 2.0,
      flapDuration: 2.0 + Math.random() * 3.0,
      targetTimeScale: bts, currentTimeScale: bts, baseTimeScale: bts,
      bankAngle: 0, pitchAngle: 0,
    });
  }
  checkReady();
});

// ── PLANET ──
const planetUrl = b64ToUrl('planetdata', 'model/gltf-binary');
loader.load(planetUrl, gltf => {
  URL.revokeObjectURL(planetUrl);
  const model = gltf.scene;
  model.traverse(c => {
    if (c.isMesh) {
      c.frustumCulled = false;
      if (c.material) {
        const mn = (c.material.name || '').toLowerCase();
        const oMap = c.material.map;
        const oNorm = c.material.normalMap;
        if (mn.includes('cloud')) {
          c.material = new THREE.MeshPhysicalMaterial({
            map: oMap, normalMap: oNorm, transparent: true, opacity: 0.35,
            roughness: 0.3, metalness: 0, emissive: new THREE.Color(0xc0a0f0),
            emissiveIntensity: 0.10, side: THREE.FrontSide, depthWrite: false,
          });
        } else {
          c.material = new THREE.MeshPhysicalMaterial({
            map: oMap, normalMap: oNorm, roughness: 0.45, metalness: 0.05,
            emissive: new THREE.Color(0x6633aa), emissiveIntensity: 0.25,
            clearcoat: 0.12, clearcoatRoughness: 0.4,
          });
        }
      }
    }
  });
  planetGroup.add(model);
  if (gltf.animations && gltf.animations.length > 0) {
    planetMixer = new THREE.AnimationMixer(model);
    const action = planetMixer.clipAction(gltf.animations[0]);
    action.timeScale = 0.15;
    action.play();
  }
  checkReady();
});

// ── SATURN ── (External file for mobile compatibility)
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://unpkg.com/three@0.162.0/examples/jsm/libs/draco/');

function applySaturnMaterials(root) {
  root.traverse(c => {
    if (c.isMesh) {
      c.frustumCulled = false;
      if (c.material) {
        const mn = (c.material.name || '').toLowerCase();
        const tex = c.material.map;
        if (mn.includes('saturn1')) {
          c.material = new THREE.MeshBasicMaterial({
            map: tex, color: new THREE.Color(0xe8d0a0),
          });
        } else if (mn.includes('saturn2')) {
          c.material = new THREE.MeshBasicMaterial({
            map: tex, color: new THREE.Color(0xddc899),
            side: THREE.DoubleSide, transparent: true, alphaTest: 0.01,
          });
        } else {
          c.material = new THREE.MeshBasicMaterial({
            map: tex, color: new THREE.Color(0xccbbaa),
          });
        }
        if (c.material.map) {
          c.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
          c.material.map.minFilter = THREE.LinearMipmapLinearFilter;
        }
        c.material.needsUpdate = true;
      }
    }
  });
}

// Load Saturn ONCE, clone for second instance (v11 optimization)
const saturnLoader1 = new GLTFLoader();
saturnLoader1.setDRACOLoader(dracoLoader);
const saturnUrl1 = b64ToUrl('saturndata', 'model/gltf-binary');
saturnLoader1.load(saturnUrl1, gltf => {
  URL.revokeObjectURL(saturnUrl1);

  // First instance: star Saturn
  applySaturnMaterials(gltf.scene);
  saturnGroup.add(gltf.scene);
  checkReady();

  // Second instance: deep clone scene graph + textures for independent materials
  const cloned = gltf.scene.clone(true);
  cloned.traverse(c => {
    if (c.isMesh && c.material) {
      c.material = c.material.clone();
      if (c.material.map) c.material.map = c.material.map.clone();
    }
  });
  applySaturnMaterials(cloned);
  saturnMainGroup.add(cloned);
  checkReady();
});
// SCENE B: THE PHYSICAL ROOM — Premium v3
// ═══════════════════════════════════════════════════════
const roomScene = new THREE.Scene();
roomScene.background = new THREE.Color(0x030303);

// v3: Subtle room fog for atmospheric depth
roomScene.fog = new THREE.FogExp2(0x0a0808, 0.025);

// Room camera
const roomCamera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.05, 50);
roomCamera.position.set(0, EYE_H, 0.01);

const controls = new OrbitControls(roomCamera, renderer.domElement);
controls.target.set(0, EYE_H, 0);
controls.enablePan = false;
controls.enableZoom = true;
controls.minDistance = 0.01;
controls.maxDistance = 0.6;
controls.rotateSpeed = 0.4;
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.update();

// ── BLOOM POST-PROCESSING ── (subtle cinematic glow on room view)
const bloomComposer = new EffectComposer(renderer);
const roomRenderPass = new RenderPass(roomScene, roomCamera);
bloomComposer.addPass(roomRenderPass);
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  0.15,    // strength — barely perceptible cinematic touch
  0.6,     // radius — soft spread
  0.85     // threshold — only brightest areas bloom (planets, horizon glow)
);
bloomComposer.addPass(bloomPass);

// ── WALL MATERIAL ──
const wallMat = new THREE.MeshBasicMaterial({
  map: stripRT.texture,
  side: THREE.FrontSide,
});
stripRT.texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

function makeWall(width, height, position, rotation, uStart, uEnd) {
  const geo = new THREE.PlaneGeometry(width, height, 1, 1);
  const uvs = geo.attributes.uv;
  uvs.setXY(0, uStart, 1);
  uvs.setXY(1, uEnd, 1);
  uvs.setXY(2, uStart, 0);
  uvs.setXY(3, uEnd, 0);
  uvs.needsUpdate = true;
  const mesh = new THREE.Mesh(geo, wallMat);
  mesh.position.copy(position);
  mesh.rotation.y = rotation;
  return mesh;
}

const uFrontEnd = ROOM_W / PERIM;
const uRightEnd = uFrontEnd + ROOM_L / PERIM;
const uBackEnd = uRightEnd + ROOM_W / PERIM;
const uvOlap = 1.0 / STRIP_W;  // 1-texel overlap eliminates seam between wall planes

roomScene.add(makeWall(ROOM_W, ROOM_H, new THREE.Vector3(0, ROOM_H/2, -ROOM_L/2), 0, 0, uFrontEnd + uvOlap));
roomScene.add(makeWall(ROOM_L, ROOM_H, new THREE.Vector3(ROOM_W/2, ROOM_H/2, 0), -Math.PI/2, uFrontEnd - uvOlap, uRightEnd + uvOlap));
roomScene.add(makeWall(ROOM_W, ROOM_H, new THREE.Vector3(0, ROOM_H/2, ROOM_L/2), Math.PI, uRightEnd - uvOlap, uBackEnd + uvOlap));
roomScene.add(makeWall(ROOM_L, ROOM_H, new THREE.Vector3(-ROOM_W/2, ROOM_H/2, 0), Math.PI/2, uBackEnd - uvOlap, 1.0));

// ── WALL LABELS — tiny golden letters for reference ──
function makeWallLabel(letter, position, rotationY) {
  const canvas = document.createElement('canvas');
  canvas.width = 128; canvas.height = 128;
  const ctx = canvas.getContext('2d');
  ctx.font = '60px Georgia, serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'rgba(196, 168, 130, 0.35)';  // Subtle gold, barely visible
  ctx.fillText(letter, 64, 64);
  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false });
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), mat);
  mesh.position.copy(position);
  mesh.rotation.y = rotationY;
  roomScene.add(mesh);
}
// A = Back short wall (far from planet), B = Left long wall (planet), C = Front short wall (near planet), D = Right long wall (facing planet)
makeWallLabel('A', new THREE.Vector3(0, ROOM_H - 0.25, ROOM_L/2 - 0.002), Math.PI);      // Back
makeWallLabel('B', new THREE.Vector3(-ROOM_W/2 + 0.002, ROOM_H - 0.25, 0), Math.PI/2);   // Left (planet)
makeWallLabel('C', new THREE.Vector3(0, ROOM_H - 0.25, -ROOM_L/2 + 0.002), 0);           // Front
makeWallLabel('D', new THREE.Vector3(ROOM_W/2 - 0.002, ROOM_H - 0.25, 0), -Math.PI/2);   // Right

// ── FLOOR — Dark grey matte vinyl with dynamic wall-light tinting ──
// MeshBasicMaterial guarantees the grey is visible (no lighting dependency).
// We manually tint the floor colour in the animation loop to simulate
// subtle wall projection spill — matching the real SABDA behaviour.

const vinylCvs = document.createElement('canvas');
vinylCvs.width = 256; vinylCvs.height = 256;
const vCtx = vinylCvs.getContext('2d');
vCtx.fillStyle = '#787878';
vCtx.fillRect(0, 0, 256, 256);
const vImg = vCtx.getImageData(0, 0, 256, 256);
for (let i = 0; i < vImg.data.length; i += 4) {
  const nudge = (Math.random() - 0.5) * 10;
  vImg.data[i]   = Math.min(255, Math.max(0, vImg.data[i] + nudge));
  vImg.data[i+1] = Math.min(255, Math.max(0, vImg.data[i+1] + nudge));
  vImg.data[i+2] = Math.min(255, Math.max(0, vImg.data[i+2] + nudge));
}
vCtx.putImageData(vImg, 0, 0);
const vinylTex = new THREE.CanvasTexture(vinylCvs);
vinylTex.wrapS = vinylTex.wrapT = THREE.RepeatWrapping;
vinylTex.repeat.set(6, 6);

const floorMat = new THREE.MeshStandardMaterial({
  color: 0x787878,
  map: vinylTex,
  roughness: 0.75,      // Mostly matte vinyl, but with a hint of sheen
  metalness: 0.05,
  envMap: cubeRT.texture,
  envMapIntensity: 0.08, // Barely there — ghost of the sky on dark vinyl
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, ROOM_L, 1, 1), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = 0;
roomScene.add(floor);
const FLOOR_BASE_R = 0x78/255, FLOOR_BASE_G = 0x78/255, FLOOR_BASE_B = 0x78/255;

// ── CEILING — Black, matching real SABDA (projectors mounted here) ──
const ceilMat = new THREE.MeshBasicMaterial({ color: 0x0a0a0a });
const ceil = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, ROOM_L), ceilMat);
ceil.rotation.x = Math.PI / 2;
ceil.position.y = ROOM_H;
roomScene.add(ceil);

// ═══════════════════════════════════════════════════════
// ROOM LIGHTING — matched to real SABDA photo
// Floor receives soft diffuse colour wash from projections.
// Brighter near walls, fading toward centre.
// ═══════════════════════════════════════════════════════

// Ambient — floor must read as grey, not black
const roomAmbient = new THREE.AmbientLight(0xaaa0a0, 0.3);
roomScene.add(roomAmbient);

// Hemisphere: warm from projection walls, dark from ceiling
const roomHemi = new THREE.HemisphereLight(0xc09070, 0x080810, 0.5);
roomScene.add(roomHemi);

// Floor lighting: hemisphere + ambient only — no PointLight hotspots
// The roomHemi tracks wall colour dynamically, providing natural even spill

// ── ARCHITECTURAL DETAILS ──
// Subtle corner shadows — thin dark seams where walls meet, like real room
const hw = ROOM_W / 2, hl = ROOM_L / 2;
const cornerMat = new THREE.MeshBasicMaterial({ 
  color: 0x1a1a1a,        // Dark grey, not pure black
  transparent: true,
  opacity: 0.5,            // Soft, not harsh
});
// Thin vertical strips (5mm wide) at each corner — only Wall A corners (back wall)
for (const [x, z, ry] of [
  [hw, hl, -Math.PI/4],
  [-hw, hl, Math.PI/4],
]) {
  const m = new THREE.Mesh(new THREE.PlaneGeometry(0.04, ROOM_H), cornerMat);
  m.position.set(x, ROOM_H/2, z);
  m.rotation.y = ry;
  roomScene.add(m);
}

// Resize
function onResize() {
  roomCamera.aspect = innerWidth / innerHeight;
  roomCamera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  bloomComposer.setSize(innerWidth, innerHeight);
}
addEventListener('resize', onResize);

// ═══════════════════════════════════════════════════════
// ANIMATION LOOP
// ═══════════════════════════════════════════════════════
const br = t => (Math.sin(t * Math.PI * 2 / BREATH - Math.PI / 2) + 1) / 2;
const colT = new THREE.Color(), colC = new THREE.Color(0.7, 0.5, 0.4);
let time = 0, lastT = performance.now() / 1000;

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now() / 1000;
  const dt = Math.min(now - lastT, 0.04);
  lastT = now;
  time += dt;

  // ── SKY DRIFT — 30-minute full cycle (2 per 1-hour class) ──
  const SKY_ROTATION_PERIOD = 1800;  // 30 minutes
  skySphere.rotation.y = (time / SKY_ROTATION_PERIOD) * Math.PI * 2;

  // ── DUST PARTICLE DRIFT ──
  dustMat.uniforms.uTime.value = time;
  const dPos = dustGeo.attributes.position.array;
  for (let i = 0; i < DUST_COUNT; i++) {
    const i3 = i * 3;
    // Drift with per-particle velocity + gentle sine wander
    dPos[i3]     += dustSpeeds[i3]     + Math.sin(time * 0.3 + dustPhases[i]) * 0.0005;
    dPos[i3 + 1] += dustSpeeds[i3 + 1] + Math.sin(time * 0.2 + dustPhases[i] * 1.7) * 0.0003;
    dPos[i3 + 2] += dustSpeeds[i3 + 2] + Math.cos(time * 0.25 + dustPhases[i] * 0.8) * 0.0005;
    // Respawn if too far away (>35m) or too high (>20m)
    const dx = dPos[i3], dy = dPos[i3 + 1], dz = dPos[i3 + 2];
    if (dx*dx + dy*dy + dz*dz > 35*35 || dy > 20) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 3 + Math.random() * 10;
      dPos[i3]     = Math.sin(phi) * Math.cos(theta) * r;
      dPos[i3 + 1] = Math.sin(phi) * Math.sin(theta) * r - 2;
      dPos[i3 + 2] = Math.cos(phi) * r;
    }
  }
  dustGeo.attributes.position.needsUpdate = true;

  // ── BREATHING + COLOUR CYCLE ──
  const b = br(time);
  const hue = (time / CCYCLE) % 1;
  colT.setHSL(hue, 0.45, 0.45);
  colC.lerp(colT, 0.004);
  const tR = 0.5 + colC.r * 0.5, tG = 0.5 + colC.g * 0.5, tB = 0.5 + colC.b * 0.5;
  ambient.color.setRGB(0.42 * tR, 0.33 * tG, 0.25 * tB);
  hemi.color.setRGB(0.77 * tR, 0.50 * tG, 0.25 * tB);
  hemi.groundColor.setRGB(0.10 * tB, 0.15 * tG, 0.12 * tR);
  rim.color.setRGB(0.25 * tB, 0.31 * tG, 0.50 * tR);
  renderer.toneMappingExposure = 0.9 + b * 0.12;
  hemi.intensity = 0.35 + b * 0.06;
  // sun.intensity and ambient.intensity set by sky colour shift below

  // ── SKY COLOUR TEMPERATURE SHIFT ──
  // Sine wave over 30 min: warm golden dusk → cool blue-purple twilight → warm again
  const skyPhase = (time / 60) * Math.PI * 2;
  const warmth = (Math.sin(skyPhase) + 1) / 2;  // 0 = coolest (twilight), 1 = warmest (golden dusk)
  // Tint sky sphere — warm golden at peak, cool blue-purple at trough
  const skyR = 0.85 + warmth * 0.15;
  const skyG = 0.82 + warmth * 0.10;
  const skyB = 0.88 + (1 - warmth) * 0.12;
  skySphereMat.color.setRGB(skyR, skyG, skyB);
  // Sun dims during cool phase, brightens during warm — breathing modulates on top
  sun.intensity = 0.5 + warmth * 0.4 + b * 0.1;
  sun.color.setRGB(
    tR * (0.8 + warmth * 0.2),
    0.56 * tG * (0.6 + warmth * 0.4),
    0.31 * tB * (0.7 + warmth * 0.3)
  );
  ambient.intensity = 0.30 + warmth * 0.10 + b * 0.06;
  // Fog colour shifts with sky
  contentScene.fog.color.setRGB(
    0.55 + warmth * 0.10,
    0.43 + warmth * 0.05,
    0.52 + (1 - warmth) * 0.08
  );
  // Dust particles shift warm/cool with sky
  dustMat.uniforms.uColor.value.setRGB(
    0.9 + warmth * 0.1,
    0.75 + warmth * 0.13,
    0.50 + (1 - warmth) * 0.20
  );

  // ── STARS — fade in during cool/twilight phase, fade out during warm ──
  starMat.uniforms.uTime.value = time;
  starMat.uniforms.uOpacity.value = Math.pow(1 - warmth, 1.5) * 0.40;  // Max 0.7 at peak twilight

  // ── GOD RAYS — stronger during warm phase, fade during twilight ──
  const rayOpacity = warmth * 0.3 + 0.05;  // 0.05–0.35 — barely perceptible
  for (const rm of rayMeshes) {
    rm.material.opacity = rayOpacity;
    // Gentle sway
    rm.rotation.z = Math.sin(time * 0.05 + rm.position.x * 0.01) * 0.03;
  }
  // Rotate god rays with sky
  rayGroup.rotation.y = skySphere.rotation.y;

  // ── SHOOTING STAR ──
  const ss = shootingStarState;
  if (!ss.active) {
    ss.timer -= dt;
    if (ss.timer <= 0) {
      ss.active = true;
      ss.maxLife = 0.7 + Math.random() * 0.4;  // 0.7-1.1s
      ss.life = ss.maxLife;
      // Random position in upper sky
      const sTheta = Math.random() * Math.PI * 2;
      const sElev = (25 + Math.random() * 35) * Math.PI / 180;
      const sR = 340;
      ss.pos.set(
        Math.cos(sElev) * Math.cos(sTheta) * sR,
        Math.sin(sElev) * sR,
        Math.cos(sElev) * Math.sin(sTheta) * sR
      );
      // Natural meteor: shallow arc
      const speed = 180 + Math.random() * 100;
      const vTheta = sTheta + (Math.random() > 0.5 ? 1 : -1) * (0.7 + Math.random() * 0.8);
      const downFrac = 0.08 + Math.random() * 0.12;
      ss.vel.set(Math.cos(vTheta) * speed, -speed * downFrac, Math.sin(vTheta) * speed);
      ssHead.visible = true;
      ssTail.visible = true;
    }
  }
  if (ss.active) {
    ss.life -= dt;
    const progress = 1 - ss.life / ss.maxLife;
    const opacity = progress < 0.06 ? progress / 0.06 : Math.pow(Math.max(0, 1 - progress), 1.6);
    ss.pos.addScaledVector(ss.vel, dt);
    // Head
    ssHead.position.copy(ss.pos);
    ssHead.scale.setScalar(opacity);
    // Tail: stretched cone behind head
    const tailLen = Math.min(progress * ss.maxLife, 0.3) * ss.vel.length() * opacity;
    if (tailLen > 0.1) {
      const velNorm = ss.vel.clone().normalize();
      ssTail.position.copy(ss.pos).sub(velNorm.multiplyScalar(tailLen * 0.5));
      ssTail.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), ss.vel.clone().normalize());
      ssTail.scale.set(opacity, tailLen, opacity);
    }
    ssTailMat.opacity = opacity * 0.6;
    ssHeadMat.color.setRGB(1, 0.97 - progress * 0.1, 0.88 - progress * 0.2);
    if (ss.life <= 0) {
      ss.active = false;
      ssHead.visible = false;
      ssTail.visible = false;
      ss.timer = 12;
    }
  }

  // v3: Room glow lights breathe with content
  // Room lighting tracks wall brightness
  const glowBreath = 0.88 + b * 0.18;
  const wallBrightness = (0.3 + warmth * 0.7) * glowBreath;
  // Hemisphere shifts colour + intensity with walls
  roomHemi.color.setRGB(0.65 * tR * glowBreath, 0.50 * tG * glowBreath, 0.40 * tB * glowBreath);
  roomHemi.intensity = 0.45 * wallBrightness;
  // Ambient also tracks
  roomAmbient.intensity = 0.15 + wallBrightness * 0.2;

  // Floor: static base colour, PointLights handle wall spill naturally

  // Planet
  planetGroup.rotation.y += dt * 0.006;
  saturnGroup.rotation.y += dt * 0.004;
  saturnMainGroup.rotation.y += dt * 0.005;
  if (planetMixer) planetMixer.update(dt);
  if (glowMat) glowMat.opacity = 0.50 + b * 0.15;

  // ── BIRDS — v3: Smoother banking ──
  for (const bd of birdFlocks) {
    bd.glideTimer -= dt;
    if (bd.glideTimer <= 0) {
      bd.isGliding = !bd.isGliding;
      bd.glideTimer = bd.isGliding ? bd.glideDuration + Math.random() * 0.5 : bd.flapDuration + Math.random() * 2;
      bd.targetTimeScale = bd.isGliding ? 0.35 : bd.baseTimeScale + Math.random() * 0.15;
    }
    bd.currentTimeScale += (bd.targetTimeScale - bd.currentTimeScale) * 1.5 * dt;
    bd.action.timeScale = bd.currentTimeScale;
    bd.mixer.update(dt);

    bd.turnChangeTimer -= dt;
    if (bd.turnChangeTimer <= 0) {
      bd.desiredTurnRate = (Math.random() - 0.5) * 0.025;
      if (Math.random() < 0.25) bd.desiredTurnRate *= 0.15;
      bd.turnChangeTimer = 6 + Math.random() * 9;
    }

    const px = bd.ctr.position.x, pz = bd.ctr.position.z;
    const dist = Math.sqrt(px * px + pz * pz);
    let btb = 0;
    if (dist > bd.homeDist + 5) {
      const tc = Math.atan2(-pz, -px);
      let hd = tc - bd.heading;
      while (hd > Math.PI) hd -= Math.PI * 2; while (hd < -Math.PI) hd += Math.PI * 2;
      btb = hd * 0.008 * (1 + Math.min(1, (dist - bd.homeDist - 5) * 0.05) * 3);
    }
    if (dist < 10) {
      const aa = Math.atan2(pz, px);
      let ad = aa - bd.heading;
      while (ad > Math.PI) ad -= Math.PI * 2; while (ad < -Math.PI) ad += Math.PI * 2;
      btb = ad * 0.01;
    }

    bd.turnRate += (bd.desiredTurnRate + btb - bd.turnRate) * 0.4 * dt;
    bd.turnRate = Math.max(-0.03, Math.min(0.03, bd.turnRate));
    bd.heading += bd.turnRate * dt;
    bd.ctr.position.x += Math.sin(bd.heading) * bd.cruiseSpeed;
    bd.ctr.position.z += Math.cos(bd.heading) * bd.cruiseSpeed;

    const alt = bd.homeY + (bd.isGliding ? -0.6 : 0.4);
    bd.vy += (alt - bd.ctr.position.y) * 0.03 * dt; bd.vy *= 0.96;
    bd.ctr.position.y += bd.vy;
    if (bd.ctr.position.y < 2.5) { bd.ctr.position.y = 2.5; bd.vy = Math.max(bd.vy, 0); }
    if (bd.ctr.position.y > 7.0) { bd.ctr.position.y = 7.0; bd.vy = Math.min(bd.vy, 0); }

    if (dist > 45) {
      const a = Math.atan2(pz, px) + Math.PI;
      bd.ctr.position.x = Math.cos(a) * bd.homeDist;
      bd.ctr.position.z = Math.sin(a) * bd.homeDist;
      bd.heading = a;
    }

    // v3: Gentler banking — multiplier 5 (was 8)
    bd.bankAngle += (-bd.turnRate * 5 - bd.bankAngle) * 1.5 * dt;
    bd.ctr.rotation.z = bd.bankAngle;
    bd.pitchAngle += (-bd.vy * 2.5 - bd.pitchAngle) * 1.5 * dt;
    bd.ctr.rotation.x = bd.pitchAngle;
    bd.ctr.rotation.y = bd.heading;
  }

  // ═══════════════════════════════════════
  // RENDER
  // ═══════════════════════════════════════

  // Step 1: Content → cube faces (WITH tonemapping)
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.setRenderTarget(null);
  cubeCamera.update(renderer, contentScene);

  // Step 2: Cube → equirect strip (NO tonemapping)
  renderer.toneMapping = THREE.NoToneMapping;
  equirectMat.uniforms.tCube.value = cubeRT.texture;
  renderer.setRenderTarget(stripRT);
  renderer.render(equirectScene, equirectCamera);
  renderer.setRenderTarget(null);

  // Step 3: Room → screen with bloom (subtle cinematic glow)
  renderer.toneMapping = THREE.NoToneMapping;
  renderer.toneMappingExposure = 1.0;
  controls.update();
  bloomComposer.render();

  // Restore content exposure for next frame
  renderer.toneMappingExposure = 0.9 + br(time) * 0.12;
}

onResize();
animate();
</script>
</body>
</html>
